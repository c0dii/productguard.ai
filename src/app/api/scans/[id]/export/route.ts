import { createClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

export async function GET(request: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await params;
    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Fetch scan details
    const { data: scan } = await supabase
      .from('scans')
      .select('*, products(name, price, type, url)')
      .eq('id', id)
      .eq('user_id', user.id)
      .single();

    if (!scan) {
      return NextResponse.json({ error: 'Scan not found' }, { status: 404 });
    }

    // Fetch all infringements
    const { data: infringements } = await supabase
      .from('infringements')
      .select('*')
      .eq('scan_id', id)
      .order('risk_level', { ascending: false });

    // Generate a simple text-based report
    // TODO: Use a PDF library like jsPDF or Puppeteer for proper PDF generation
    const report = generateTextReport(scan, infringements || []);

    // Return as downloadable text file for now
    return new NextResponse(report, {
      headers: {
        'Content-Type': 'text/plain',
        'Content-Disposition': `attachment; filename="scan_report_${id.slice(0, 8)}.txt"`,
      },
    });
  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json({ error: 'Export failed' }, { status: 500 });
  }
}

function generateTextReport(scan: any, infringements: any[]): string {
  const critical = infringements.filter((i) => i.risk_level === 'critical');
  const high = infringements.filter((i) => i.risk_level === 'high');
  const medium = infringements.filter((i) => i.risk_level === 'medium');
  const low = infringements.filter((i) => i.risk_level === 'low');

  const totalRevenueLoss = infringements.reduce((sum, i) => sum + (i.est_revenue_loss || 0), 0);

  let report = `
=================================================================
                  PIRACY SCAN REPORT
=================================================================

Product: ${scan.products?.name || 'Unknown'}
Product Type: ${scan.products?.type || 'N/A'}
Scan Date: ${new Date(scan.created_at).toLocaleString()}
Scan Status: ${scan.status}

-----------------------------------------------------------------
                    SUMMARY
-----------------------------------------------------------------

Total Infringements Found: ${infringements.length}
Critical Threats: ${critical.length}
High Risk: ${high.length}
Medium Risk: ${medium.length}
Low Risk: ${low.length}

Estimated Revenue Loss: $${totalRevenueLoss.toLocaleString()}

-----------------------------------------------------------------
                DETAILED INFRINGEMENTS
-----------------------------------------------------------------
`;

  // Critical
  if (critical.length > 0) {
    report += `\nðŸš¨ CRITICAL THREATS (${critical.length})\n`;
    report += '='.repeat(65) + '\n\n';
    critical.forEach((inf, idx) => {
      report += formatInfringement(inf, idx + 1);
    });
  }

  // High
  if (high.length > 0) {
    report += `\nâš ï¸  HIGH RISK (${high.length})\n`;
    report += '='.repeat(65) + '\n\n';
    high.forEach((inf, idx) => {
      report += formatInfringement(inf, idx + 1);
    });
  }

  // Medium
  if (medium.length > 0) {
    report += `\nâ„¹ï¸  MEDIUM RISK (${medium.length})\n`;
    report += '='.repeat(65) + '\n\n';
    medium.forEach((inf, idx) => {
      report += formatInfringement(inf, idx + 1);
    });
  }

  // Low
  if (low.length > 0) {
    report += `\nâ—‹ LOW RISK (${low.length})\n`;
    report += '='.repeat(65) + '\n\n';
    low.forEach((inf, idx) => {
      report += formatInfringement(inf, idx + 1);
    });
  }

  report += `
-----------------------------------------------------------------
           Generated by ProductGuard.ai
           https://productguard.ai
-----------------------------------------------------------------
`;

  return report;
}

function formatInfringement(inf: any, index: number): string {
  return `
${index}. ${inf.source_url}

   Platform: ${inf.platform}
   Type: ${inf.type}
   Risk Level: ${inf.risk_level.toUpperCase()}
   Audience Size: ${inf.audience_size || 'Unknown'}
   Est. Revenue Loss: $${(inf.est_revenue_loss || 0).toLocaleString()}
   Status: ${inf.status}
   Detected: ${new Date(inf.created_at).toLocaleDateString()}

   ---------------------------------------------------------
`;
}
